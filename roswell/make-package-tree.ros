#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#

(eval-when (:execute)
  (ql:quickload '(:anaphora :s-dot :cl-ppcre :cl-cli) :silent t)
  (use-package :anaphora)
  ;; enable to write as "$node" instead of "s-dot::node"
  (set-macro-character #\$ #'(lambda (stream &rest rest)
                               (declare (ignore rest))
                               (let ((sym (read stream nil)))
                                 (intern (symbol-name sym) "S-DOT")))))

(defstruct package-info
  name
  use-lst
  export-lst
  import-lst)

(defstruct graph-parts
  cluster-lst
  edge-lst)

;; ----- utils ----- ;;

(defun is-family-pack (pack-name system-name)
  (ppcre:scan (format nil "~A.*" system-name) pack-name))

;; Use a queue rather than a stack because I think that the depth first search (by stack) puts elder nodes in a package tree away.
(defvar *target-pack-queue* nil)
(defvar *processed-pack-list* nil)

(defun queue-pack-name (pack-name system-name)
  (unless (or (not (is-family-pack pack-name system-name))
              (find pack-name *target-pack-queue* :test #'string=)
              (find pack-name *processed-pack-list* :test #'string=))
    (setf *target-pack-queue*
          (nreverse (cons pack-name (nreverse *target-pack-queue*))))))

(defun dequeue-pack-name ()
  (awhen (pop *target-pack-queue*)
    (push it *processed-pack-list*)
    it))

;; ----- read file ----- ;;

(defun interpret-package (target-pack-name system-name)
  (let ((export-lst nil)
        (import-hash (make-hash-table)))
    (do-symbols (sym target-pack-name)
      (let ((pack-name (package-name (symbol-package sym))))
        (queue-pack-name pack-name system-name)
        (cond ((string= pack-name target-pack-name)
               (multiple-value-bind (found type) (find-symbol (symbol-name sym) pack-name)
                 (declare (ignore found))
                 (when (eq type :external)
                   (push sym export-lst))))
              ((is-family-pack pack-name system-name)
               (push sym (gethash pack-name import-hash))))))
    (make-package-info :name target-pack-name
                       :use-lst (mapcar #'package-name
                                        (package-use-list (find-package target-pack-name)))
                       :export-lst export-lst
                       :import-lst import-hash)))

;; ----- make graph ----- ;;

(defun format-name (name)
  (let ((s-name (if (symbolp name)
                    (symbol-name name)
                    name)))
    (string-upcase
     (car (last
           (ppcre:split
            "\\."
            (ppcre:regex-replace-all
             "[\\+\\*]" 
             (ppcre:regex-replace-all "-" s-name "_")
             "__")))))))

;; In graphviz, because we can't directly draw edges from a cluster,
;; draw them from the 'master' node that has no label, instead.
(defun make-master-node-name (name)
  (format nil "MASTER_~A" (format-name name)))

(defun node (name)
  (alet (format-name name)
    `($node (($id ,it)
             ($label ,it)
             ($width "0.1")
             ($height "0.1")))))

(let* ((color-lst '("red" "blue" "black" "green" "skyblue" "gold" "brown" "gray" "Turquoise"))
      (color-pnt color-lst))
  (defun edge-color ()
    (car color-pnt))
  (defun change-edge-color ()
    (aif (cdr color-pnt)
         (setf color-pnt it)
         (setf color-pnt color-lst))))

(defun edge (from to)
  `($edge (($from ,(format-name from))
           ($to ,(format-name to))
           ($color ,(edge-color)))))

(defun cluster (name node-keyward-lst)
  (let ((fname (format-name name)))
    `($cluster (($id ,fname)
                ($label ,fname))
               ($node (($id ,(make-master-node-name name))
                       ($label "")
                       ($width "0.1")
                       ($height "0.1")))
               ,@(mapcar #'(lambda (elem) (node (format-name elem)))
                         node-keyward-lst))))

(defun add-info-to-graph (graph pack-info system-name &key (only-package nil))
  (change-edge-color)
  (with-slots (name use-lst export-lst import-lst) pack-info
    (push (cluster name (unless only-package export-lst))
          (graph-parts-cluster-lst graph))
    (slet (graph-parts-edge-lst graph)
      (let ((master-name (make-master-node-name name)))
        (dolist (use (remove-if (lambda (pack-name)
                                  (not (is-family-pack pack-name system-name)))
                                use-lst))
          (push (edge master-name (make-master-node-name use))
                it))
        (maphash (lambda (pack-name sym-lst)
                   (unless (find pack-name use-lst :test #'string=)
                     (if only-package
                         (push (edge master-name (make-master-node-name pack-name))
                               it)
                         (dolist (elem sym-lst)
                           (push (edge master-name elem)
                                 it)))))
                 import-lst))))
  graph)

(defun render-graph (graph file)
  ($render-s-dot file "png"
                 `($graph (($rankdir "LR"))
                          ,@(graph-parts-cluster-lst graph)
                          ,@(graph-parts-edge-lst graph))))

;; ----- getopt ----- ;;

(defvar *only-package* nil)
(defvar *output* #p"temp.png")

(defvar *options*
  '((*only-package* nil "Show only packages (doesn't show symbols)" :alias ("-P"))
    (*output* #p"temp.png" "Place the output into <file>" :alias ("-o") :params ("FILE"))))

(defun print-help ()
  (cl-cli:help *options* nil
               :prolog "./make-package-tree.ros [OPTION]... PACKAGE-NAME"))

;; ----- main ----- ;; 

(defun main (&rest argv)
  (declare (ignorable argv))
  (unless (> (length argv) 0)
    (print-help)
    (return-from main))
  (multiple-value-bind (names vals sub1 sub2 rest)
      ;; cl-cli:parce-cli ignore the head of the list
      (cl-cli:parse-cli (cons nil argv) *options*)
    (declare (ignore sub1 sub2))
    (cl-cli:with-environment names vals
      (let ((system-name (string-upcase (car rest)))
            (graph (make-graph-parts)))
        (ql:quickload system-name)
        (do ((pack-name system-name (dequeue-pack-name)))
            ((null pack-name))
          (print pack-name)
          (add-info-to-graph graph
                             (interpret-package pack-name system-name)
                             system-name
                             :only-package *only-package*))
        (render-graph graph *output*)
        (format t "~%~%Output to \"~A\"~%" *output*))))) 
